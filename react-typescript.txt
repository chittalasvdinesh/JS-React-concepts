const Greet=({name}:{name:string})=>{
    return <>
    <h2>Hello,{name} how are you</h2>
    </>
};

export default Greet;


or

type GreetProps={
    name:string
}


const Greet=(props:GreetProps)=>{
    return <>
    <h2>Hello,{props.name} how are you</h2>
    </>
};

export default Greet;


    familyList:{
        first:string,
        last:string
    }[]



ex:

 type StatusProps={
    status:"loading" | "successful" | "error";
 }
 const Status=(props:StatusProps)=>{
    let message;

  if(props.status==="loading") message="Data Loading..." 
  else if(props.status==="successful") message="Data Fetched Successfully"
  else message="Error While fetching Data"

    return <>
   <h2>Status-{message}</h2>
    </>
};

export default Status;


ex:

const Heading=({children}:{children:string})=>{
    return <div>{children}</div>
};

export default Heading;


ex: component as a children prop

const Oscar=({children}:{children:React.ReactNode})=>{
    return <div>
        {children}
    </div>
};


export default Oscar;

ex: optional props
type GreetProps={
    name:string,
    messageCount?:number,
    isLoggedIn:boolean
    
}


ex: events
ex-1: onClick event with no return

 const Button=({handleClick}:{handleClick:()=>void})=>{
    return <button onClick={handleClick}>Click</button>
};

export default Button;

ex-2: event as a parameter:
       <Button handleClick={(event)=>console.log("clicked",event)}/>

or 

  const handleClick=(event:React.MouseEvent)=>{
    console.log("Clicked",event)
  }


ex: onChange event

type InputProps={
    value:string,
    handleChange:(e:React.ChangeEvent<HTMLInputElement>)=>void
}

const Input=({value,handleChange}:InputProps)=>{
    return <input type="text" value={value} onChange={handleChange} />
};

export default Input;


ex: style as props

const Container=({styles}:{styles:React.CSSProperties})=>{
    return <div style={styles}>
        text content in container
    </div>
};

export default Container;


// In real time it is good to maintain types in a seperate file instead of defining at component top.
ex:
-Person.type.ts
 export type PersonProps={
    familyList:{
        first:string,
        last:string
    }[]
}

-Person.tsx

import { PersonProps } from "./Person.types";

const Person=(props:PersonProps)=>{

    return  <ul>
        {props.familyList.map((val)=>{
            return <li>{val.first} {val.last}</li>
        })}
    </ul>
};

export default Person;



ex: Reusability of types:

export type Name = {
    first: string,
    last: string
}


export type PersonProps = {
    familyList: Name[]
}


ex: useState() hook

import { useState } from "react";

type AuthUser={
    name:string,
    email:string
}

export const User = () => {
    const[user,setUser]=useState<null|AuthUser>(null);
    const handleLogin = () => {
        setUser({name:"Dinesh",email:"dinesh@gmail.com"})
   }
   const handleLogout = () => {
    setUser(null)
   }
    return <>
     <button onClick={handleLogin}>Login</button>
        <button onClick={handleLogout}>Logout</button>
        <div>
            <p>UserName:{user?.name}</p>
            <p>Email:{user?.email}</p>

        </div>
    </>
}

ex: type assertion
type AuthUser={
    name:string,
    email:string
}

    const [user, setUser] = useState<AuthUser>({} as AuthUser);



ex: discrimanting union using useReducer() hook.

import { useReducer } from "react";

type UpdateAction = {
    type: "inc" | "dec",
    payload: number
}

type ResetAction = {
    type: "reset"
}


type CounterAction = UpdateAction | ResetAction

const initialState = { count: 0 };


function reducer(state: { count: number }, action: CounterAction) {
    switch (action.type) {
        case 'inc':
            return { count: state.count + action?.payload }
        case 'dec':
            return { count: state.count - action?.payload }
        case 'reset':
            return initialState
        default:
            return state;
    }
}



export const Counter = () => {
    const [state, dispatch] = useReducer(reducer, initialState);


    return <>
        Count: {state.count}
        <div>
            <button onClick={() => dispatch({ type: "inc", payload: 10 })}>INC</button>
            <button onClick={() => dispatch({ type: "dec", payload: 10 })}>DEC</button>
            <button onClick={() => dispatch({ type: "reset" })}>Reset</button>
        </div>
    </>
};


ex: useContext() hook
--
import React, { createContext } from "react";
import { theme } from "./theme";

export const ThemeContext=createContext(theme);

export const ThemeContextProvider=({children}:{children:React.ReactNode})=>{
     return <ThemeContext.Provider value={theme}>
        {children}
     </ThemeContext.Provider>
}

--

import { useContext } from "react"
import { ThemeContext } from "./ThemeContent"

export const Box=()=>{
    const theme=useContext(ThemeContext)
    return <div style={{background:theme.primary.main,color:theme.primary.text}}>Theme context</div>
}
--

export const theme={
    primary:{
        main:"#3f51b5",
        text: "#fff"
    },
    secondary:{
        main:"#f50057",
        text:"#fff"
    }
}

--


 <ThemeContextProvider>
       <Box/>
       </ThemeContextProvider>


 --------

 
       